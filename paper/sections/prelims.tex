For our following construction and the proof, later on, we will need certain constructs and tools.
These will be defined in the following.

\begin{definition}[\textnormal{\textit{Generator}}]
  Let \(\mathbb{G}\) be a cyclic group of order \(p\). Then a group generator is \(g\in\mathbb{G}\) such that it fulfills
    \[\mathbb{G} = \Set{g^i \bmod p \mid i\in\nats}\]
  This means, that by taking the generator to the multiple powers, while taking the modulus of \(p\), we can generate all elements of our given group.
\end{definition}

\begin{definition}[\textnormal{\textit{Discrete Logarithm}}]
  In a group \(\mathbb{G}\), we define the \textit{discrete logarithm} as an integer \(x\) such that \(b^x = a\) for an arbitrary integer \(a\) and \(b^x = \underbrace{b\cdot \ldots\cdot b}_{x \text{ times}}\).
\end{definition}

\begin{definition}[\textnormal{\textit{Hardness of the discrete logarithm?}}]
  \textcolor{blue}{Lorem Ipsum}
\end{definition}

\begin{definition}[\textnormal{\textit{Random Oracle}}]
  A \textit{random oracle} is a black-box algorithm which serves each \textit{unique} request with a truly random value. Moreover, it serves each duplicate request with the same answer it sent before.
\end{definition}

\begin{definition}[\textnormal{\textit{Chosen Message Attack}}]
  In a signature scheme, a \textit{chosen message attack} enables the adversary to get the signature of several messages, meaning it can query the signing oracle.
\end{definition}

\begin{definition}[\textnormal{\textit{Negligible function}}]
  We say a function \(f\) is negligible if 
  \[f(n) < \frac{1}{n^c}\]
  for a sufficiently large \(n\in\nats\). This means, that our function \(f\) converges towards 0. 
\end{definition}

\begin{definition}[\textnormal{\textit{Forking Lemma}}]
  In \cite{pcstern96} Pointcheval and Stern introduced a tool for signature schemes, the \textit{forking lemma}. 
  It states that if an algorithm \(E\) can produce a signature \(\goedel{r_1, h, r_2}\) with \(r_1\) has to be randomly chosen from a huge set, \(h\) being the hash of the message and \(r_1\), and \(r_2\) depending only on \(r_1, h\) and the message, on public input, then there exists another algorithm \(\mathcal{A}\) that controls said algorithm \(E\).
  \(\mathcal{A}\) can then replay \(E\), with replacing the signer by the simulation, to generate a second valid signature \(\goedel{r_1, h', r_2'}\) with \(h\neq h'\).
\end{definition}

